{"version":3,"sources":["assets/trash.png","assets/sandwich.png","MapContext.js","Waypoint.js","GpxGenerator.js","Sidebar.js","MapLayout.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","MapContext","React","createContext","markers","setMarkers","Waypoint","forwardRef","ref","text","index","deleteMarker","isDragging","connectDragSource","connectDropTarget","hovered","elementRef","useRef","opacity","useImperativeHandle","getNode","current","className","style","color","src","sandwichIcon","width","height","alt","onClick","trashIcon","DropTarget","hover","props","monitor","component","dragIndex","getItem","hoverIndex","rearrangeWaypoint","connect","dropTarget","isOver","DragSource","beginDrag","id","dragSource","GpxGenerator","useContext","xml","coordinates","map","marker","timestamp","Date","toISOString","createXmlString","url","link","document","createElement","download","href","body","appendChild","click","removeChild","Sidebar","updatedMarkers","splice","draggedWaypoint","Fragment","key","MapLayout","Map","center","zoom","event","clickedLocation","latlng","lat","lng","TileLayer","attribution","Marker","position","icon","waypointNumber","L","divIcon","html","iconAnchor","iconSize","Tooltip","Popup","Polyline","positions","weight","App","useState","value","useMemo","Provider","DndProvider","backend","HTML5Backend","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.3136572a.chunk.js","sourcesContent":["module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEwAACxMBAJqcGAAAAQFJREFUOI3tlL1OwzAUhc+5bqagiEodmJkYWXgJVlYG8gL2AhISAzMiQpHfgAdiR4D4GSsxMsCQe1kaVKiTQFW2nsX2Z/vTtSwbWHE4tKCqqolzbgMAsiyzPM+nZVm+LyWs63ofwCHJOwAgSQAnZjYOIXyk9oz6hCKyB+DMe//UshgjnHNbAF4GK4wx7gA4bcequkvygeRbFzOz1xDCcVI4J7a+yudy7b0/+naqoQ0AprP+RYItpFdoZs+q2t7obYL9TbhM1sK18B+EmyIyAgAzm/xkqrrwRLt+m0cA2yRDC0heztovJiL3vxI2TXMgIuckx6l5MzMAN0VRXHUUtLp8AtjrU8aKqFF7AAAAAElFTkSuQmCC\"","module.exports = \"data:image/png;base64,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\"","import React from \"react\";\n\nconst MapContext = React.createContext({\n  markers: [],\n  setMarkers: () => {},\n});\n\nexport default MapContext;\n","import React, { useImperativeHandle, useRef } from \"react\";\nimport { DragSource, DropTarget } from \"react-dnd\";\nimport sandwichIcon from './assets/sandwich.png'\nimport trashIcon from './assets/trash.png'\n\nconst Waypoint = React.forwardRef(\n  ({ text, index, deleteMarker, isDragging, connectDragSource, connectDropTarget, hovered }, ref) => {\n\n    const elementRef = useRef(null);\n    connectDragSource(elementRef);\n    connectDropTarget(elementRef);\n\n    const opacity = isDragging ? 0 : 1;\n    useImperativeHandle(ref, () => ({\n      getNode: () => elementRef.current\n    }));\n    \n    return (\n      <li ref={elementRef} className='item' style={{ opacity, color: hovered && \"#b1b1b1\" }}>\n        <img src={sandwichIcon} width={20} height={20} alt=\"Rearrange icon\"></img>\n        <span>{text}</span>\n        <button onClick={() => deleteMarker(index)}>\n          <img src={trashIcon} alt=\"Trash icon\"></img>\n        </button>\n      </li>\n    );\n  }\n);\n\nexport default DropTarget(\n  'waypoint',\n  {\n    hover(props, monitor, component) {\n      if (!component) {\n        return null;\n      }\n      // node = HTML Div element from imperative API\n      const node = component.getNode();\n\n      if (!node) {\n        return null;\n      }\n      const dragIndex = monitor.getItem().index;\n\n      const hoverIndex = props.index;\n      // Don't replace items with themselves\n      if (dragIndex === hoverIndex) {\n        return;\n      }\n      \n      // // Determine rectangle on screen\n      // const hoverBoundingRect = node.getBoundingClientRect();\n\n      // // Get vertical middle\n      // const hoverMiddleY = (hoverBoundingRect.bottom - hoverBoundingRect.top) / 2;\n      // // Determine mouse position\n      // const clientOffset = monitor.getClientOffset();\n      // // Get pixels to the top\n      // const hoverClientY = clientOffset.y - hoverBoundingRect.top;\n      // // Only perform the move when the mouse has crossed half of the items height\n      // // When dragging downwards, only move when the cursor is below 50%\n      // // When dragging upwards, only move when the cursor is above 50%\n      // // Dragging downwards\n      // if (dragIndex < hoverIndex && hoverClientY < hoverMiddleY) {\n      //   return;\n      // }\n      // // Dragging upwards\n      // if (dragIndex > hoverIndex && hoverClientY > hoverMiddleY) {\n      //   return;\n      // }\n\n      // Time to actually perform the action\n      props.rearrangeWaypoint(dragIndex, hoverIndex);\n   \n      // Note: we're mutating the monitor item here!\n      // Generally it's better to avoid mutations,\n      // but it's good here for the sake of performance\n      // to avoid expensive index searches.\n      monitor.getItem().index = hoverIndex;\n    },\n\n  },\n  (connect, monitor) => ({\n    connectDropTarget: connect.dropTarget(),\n    hovered: monitor.isOver(),\n  })\n)(\n  DragSource(\n    'waypoint',\n    {\n      beginDrag: (props) => { \n\n        return ({\n        id: props.index,\n        index: props.index\n      }) }\n\n      \n    },\n    (connect, monitor) => ({\n      connectDragSource: connect.dragSource(),\n      isDragging: monitor.isDragging()\n    })\n  )(Waypoint)\n);\n","import React, { useContext } from 'react'\nimport MapContext from \"./MapContext\"\n\nconst GpxGenerator = () => {\n  const { markers, setMarkers } = useContext(MapContext)\n\n  const createXmlString = () => {\n    let coordinates = markers.map((marker, index) => `<rtept lat=\"${marker[0]}\" lon=\"${marker[1]}\"><name>Waypoint ${index}</name></rtept>`)\n    var timestamp = new Date().toISOString()\n\n    let result = \n    `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n    <gpx version=\"1.1\" creator=\"https://mywebsite.com\" xmlns=\"https://mywebsite.com\">\n      <metadata>\n        <name>Route to GPX by Stefan Stoev</name>\n        <link href=\"https://mywebsite.com\">\n          <text>Route to Gpx</text>\n        </link>\n        <time>${timestamp}</time>\n        <copyright author=\"Stefan Stoev\">\n          <year>2020</year>\n        </copyright>\n      </metadata>\n      <rte>\n        ${coordinates}\n      </rte>\n    </gpx>`\n\n    return result\n  }\n  \n  const downloadGpxFile = () => {\n    const xml = createXmlString()\n    const url = `data:text/jsoncharset=utf-8,${xml}`\n    const link = document.createElement('a')\n    link.download = 'myRoute.gpx'\n    link.href = url\n    document.body.appendChild(link)\n    link.click()\n    document.body.removeChild(link);\n  }\n\n  return (\n    <button className='download-btn' onClick={downloadGpxFile}> Download your Route </button>\n  )\n}\n\nexport default GpxGenerator","import React, { useContext } from 'react'\nimport MapContext from \"./MapContext\"\nimport Waypoint from \"./Waypoint\"\nimport GpxGenerator from \"./GpxGenerator\"\nimport trashIcon from './assets/trash.png'\n\nconst Sidebar = () => {\n  const { markers, setMarkers } = useContext(MapContext)\n\n  const deleteMarker = (index) => {\n    let updatedMarkers = [...markers]\n    updatedMarkers.splice(index, 1)\n    setMarkers(updatedMarkers)\n  }\n\n  const rearrangeWaypoint = (dragIndex, hoverIndex) => {\n    const draggedWaypoint = markers[dragIndex] // get the selected waypoint\n    let updatedMarkers = [...markers] // make a clone of the markers array\n    updatedMarkers.splice(dragIndex, 1) // remove the selected waypoint from the array.\n    updatedMarkers.splice(hoverIndex, 0, draggedWaypoint) // insert it into hoverIndex.\n    setMarkers(updatedMarkers) // update the state with rearranged waypoints \n  }\n  \n  return (\n    <React.Fragment>\n      <div className='sidebar'>\n        <h2>Route Builder</h2>\n        <ul>\n          {markers.map((marker, index) => (\n            <Waypoint\n              key={index}\n              index={index}\n              text={`Waypoint ${index + 1}`}\n              rearrangeWaypoint={rearrangeWaypoint}\n              deleteMarker={deleteMarker}\n            />\n          ))}\n        </ul>\n        <GpxGenerator />\n      </div>\n    </React.Fragment>\n  )\n}\n\nexport default Sidebar\n\n\n\n\n// {markers.map((marker, index) => (\n//   <li key={index}>\n//     <span> Waypoint {index + 1} </span>\n//     <button onClick={() => deleteMarker(index)}>\n//       <img src={trashIcon} alt=\"Trash icon\"></img>\n//     </button>\n//   </li>\n// ))}\n\n  {/* <button onClick={() => deleteMarker(index)}>\n                <img src={trashIcon} alt=\"Trash icon\"></img>\n              </button> */}","import React, { useContext }  from \"react\";\nimport { Map, TileLayer, Marker, Popup, Polyline, Tooltip } from 'react-leaflet'\nimport MapContext from \"./MapContext\";\nimport L from 'leaflet'\n\nconst MapLayout = () => {\n  const { markers, setMarkers } = useContext(MapContext);\n\n  const createMarker = (event) => {\n    const clickedLocation = event.latlng\n    if (!clickedLocation.lat || !clickedLocation.lng) return null\n\n    setMarkers([...markers, [clickedLocation.lat, clickedLocation.lng]])\n  }\n\n  const getMarkerIcon = (waypointNumber) => {\n    return L.divIcon({\n      className: 'custom-icon',\n      html: waypointNumber,\n      iconAnchor: [10, 10],\n      iconSize: [20, 20],\n    })\n  }\n\n  return (\n    <Map\n      center={[42.69, 23.32]}\n      zoom={13}\n      onClick={createMarker}\n    >\n      <TileLayer\n        url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\"\n        attribution='&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\n      />\n\n      {markers.map(( marker, index ) => (\n        <Marker key={index} position={marker} icon={getMarkerIcon(index + 1)}>\n          <Tooltip> Waypoint {index + 1} </Tooltip>\n          <Popup> Waypoint {index + 1} </Popup>\n        </Marker>\n      ))}\n\n      <Polyline positions={[markers]} color={'#2278C5'} weight={5}/>\n    </Map>\n  );\n}\n\nexport default MapLayout;\n","import React, { useState, useMemo } from 'react'\nimport './App.css'\nimport Sidebar from './Sidebar'\nimport MapLayout from './MapLayout'\nimport MapContext from './MapContext'\nimport { DndProvider } from 'react-dnd'\nimport { HTML5Backend } from 'react-dnd-html5-backend'\n\nconst App = () => {\n  const [markers, setMarkers] = useState([])\n  const value = useMemo (() => ({ markers, setMarkers }), [markers, setMarkers])\n\n  return (\n    <React.Fragment>\n      <MapContext.Provider value={value}>\n        <DndProvider backend={HTML5Backend}>\n          <Sidebar/>\n        </DndProvider>\n        <MapLayout/>\n      </MapContext.Provider>\n    </React.Fragment>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}